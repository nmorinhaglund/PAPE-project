---
title: "Markdown_project_PAPE"
author: "nilsm"
date: "2025-11-04"
output:
  html_document: default
  pdf_document: default
---

# Loading the data

To load the data correctly, the R-project file should be placed in dir containing:
1) a repertory "data" containing all the data parquet files ("local.parquet")
2) the ref_ring.RData file

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Load packages
library(dplyr)
library(ggplot2)
library(sf) # library used for maps
library(arrow) # library used to read parquet files
library(lubridate) # library used to process dates and times
library(jsonlite)
library(osmdata)
library(leaflet)
library(mapedit)
library(stringr)
library(fixest)
library(rlang)
library(zoo)
library(gridExtra)


# This function loads the dataset between date_min and date_max (give them in format 'yyyy-mm-dd')
# If filter_na = TRUE, the function will not retrieve observations with no data either on flow or on occupancy rate
# If short = TRUE, the function will not retrieve the geometrical information (lighter for memory use so by default use this option!)

loading_function = function(date_min, date_max, filter_na = TRUE,short=TRUE) {
  
  if (short == TRUE) {
    filtered_cols = c("iu_ac","libelle", "t_1h", "q", "k")
  } else {
    filtered_cols = c("iu_ac", "libelle", "iu_nd_amont", "iu_nd_aval","t_1h", "q", "k", "etat_trafic", "etat_barre", "geometry")
  }
  
 res <- ds %>%
  select(all_of(filtered_cols)) %>%
  collect() %>%
  mutate(t_1h = ymd_hms(t_1h)) %>%
  filter(as.Date(t_1h) %within% interval(ymd(date_min), ymd(date_max)),
         month(t_1h) != 8)
  
  cat("Number of observations: ",nrow(res))
  
  return(res)
}



# Useful informations:
vehicle_length = 0.0045 # vehicle length mean is 4.5 meters

load('ref_ring.RData') #This RData file contains the geographical referential for the roads used in the analysis

gc()
  
  
```


# Computing arc roads
```{r}

geojson_to_sfg <- function(geojson) {
  geo <- fromJSON(geojson)
  coords <- geo$coordinates
  coords <- matrix(coords, ncol = 2)
  st_linestring(coords)  # retourne un objet sfg
}

convert_to_sf <- function(df, col) {
  df_name <- deparse(substitute(df))   # récupère le nom (ex: "VGP")
  
  geoms <- lapply(df[[col]], geojson_to_sfg)
  geoms <- st_sfc(geoms, crs = 4326)
  result <- st_sf(df, geometry = geoms)
  
  assign(paste0(df_name, "_sf"), result, envir = .GlobalEnv)
}

compute_arc_length = function(arc) {
  return(st_length(st_transform(arc, 2154))/1000)
}

ref_local_roads = rbind(Bd_St_Germain,Upper_bank,Lower_bank) %>% convert_to_sf(.,"geo_shape")
ref_ring_roads = rbind(PI_control_clean,PI_north_control_clean,PE_north_control_clean,PE_control_clean)

ref_local_roads$length = compute_arc_length(ref_local_roads)
ref_ring_roads$length = compute_arc_length(ref_ring_roads)


```


# Speed function

In the model, the speed is defined as $S(i,t) = \frac{Flow(i,t) * (L + Ki)}{Occupancy(i,t)}$ 
```{r}

compute_speed = function(df) {
  return(df$q *(vehicle_length + as.numeric(df$length))/df$k)
}


compute_speed_test = function(df) {
  return(df$q * 0.0008/(df$k/100))
}
```




# Computing the model on ring road
```{r}

ds <- open_dataset('./data/ring.parquet')

categories_function_ring = function(df){
  Final_ring = df %>% 
    mutate(treated = libelle %in% PE_control_clean$Libelle|libelle %in% PI_north_control_clean$Libelle) %>% # TRUE if arc is in the treated subset
    mutate(post = ymd(as.Date(t_1h)) > ymd("2016-09-01")) %>% # After ou before the VGP closure
    mutate(year_rel = floor(time_length(ymd(as.Date(t_1h)) - ymd("2016-08-31"), "year"))) %>% # year relative to VGP closure
    mutate(log_flow = log(q),log_occupancy = log(k)) %>% # Log of the flow and occupancy of cars
    mutate(date = as.Date(t_1h)) %>%
    mutate(wday = wday(ymd(date))) %>% # Day of the week (1 = Saturday, 2 = Monday, ..., 7 = Sunday)
    mutate(hours = hour(t_1h)) %>% # Hour of the day (0 to 23)
    mutate(day_hour = paste0(wday,'_',hours)) %>% # Wednesday at 8AM = "4_8" and Sunday at 7PM =  "7_19"
    mutate(north = libelle %in% PI_north_control_clean$Libelle|libelle %in% PE_north_control_clean$Libelle)
  
  Final_ring$daytime = ifelse(Final_ring$hours %in% c(8:20),TRUE,FALSE)
  Final_ring$morning = ifelse(Final_ring$hours %in% c(8:10),TRUE,FALSE)
  Final_ring$evening = ifelse(Final_ring$hours %in% c(18:20),TRUE,FALSE)
  
  return(Final_ring)
}


date_min = "2013-09-01"
date_max = "2019-09-01"
df_ring = loading_function(date_min,date_max) %>% 
  filter(iu_ac %in% c(PE_north_control_clean$Identifiant.arc, PE_control_clean$Identifiant.arc,PI_control_clean$Identifiant.arc,PI_north_control_clean$Identifiant.arc))

Final_ring = categories_function_ring(df_ring)

Final_ring = Final_ring %>% filter((is.na(q) & is.na(k))==F)

did_model <- feols(
  q ~ treated * post | libelle + t_1h,
  data = Final_ring,
  cluster = ~libelle
)

summary(did_model)


# A function to compute the event model:
#   - Final_ring is the data frame with the data filtered and with the categories
#   - subset is a CONDITION input ! e.g. "north == TRUE"
#   - variable to compute the model, e.g. "q", "k", "log_flow", "log_occupancy"...

compute_event_model = function(Final_ring,subset,variable) {
  
  if (!is.null(subset)){
    df = Final_ring %>% filter(!!parse_expr(subset))
  } else {df = Final_ring}
  
  event_model <- feols(
    k ~ i(year_rel, treated, ref = "-1") | libelle + day_hour,
    data = df,
    cluster = ~libelle
  )
  
  summary(event_model)
  
  betas <- coef(event_model)
  ses <- se(event_model)
  
  results<- data.frame(
    coef_name = names(betas),
    beta = betas,
    se = ses,
    ci_low = betas - 1.96 * ses,
    ci_high = betas + 1.96 * ses
  )

  results = results %>% mutate(year_rel = sapply(coef_name,function(x) {return(unlist(str_split(x,":"))[3])}))
  results[6,] = c("year_rel::-1:treated",0,0,0,0,-1) # Add a line for the reference year (-1) with an estimate and se = 0
  results = results %>% select(-coef_name) %>% mutate(across(everything(),as.numeric))
  
  return(results)
}

results_all = compute_event_model(Final_ring,subset = NULL,k)
results_south = compute_event_model(Final_ring, subset = "north == FALSE",k)

results_south$subset = "South ring roads"
results_all$subset = "Full sample"


results = rbind(results_south,results_all)

ggplot(results, aes(x = year_rel, y = beta, color = subset)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_point(size = 2, position = position_dodge(width = 0.3)) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0,position = position_dodge(width = 0.3)) +
  geom_line(position = position_dodge(width = 0.3))+
  labs(
    x = "Year relative to VGP closure",
    y = "Estimates (β_k)",
    title = "Effect of VGP closure on car occupancy rate"
  ) +
  theme_minimal() + 
  scale_color_manual(values = c("Full sample" = "black", "South ring roads" = "darkgrey"))

```



# Computing the model on local road
```{r, include=FALSE}
ds <- open_dataset('./data/local.parquet')

categories_function_local = function(df){
  Final_local = df %>% 
    mutate(treated = libelle %in% Bd_St_Germain$Libelle|libelle %in% Upper_bank$Libelle) %>% # TRUE if arc is in the treated subset
    mutate(post = ymd(as.Date(t_1h)) > ymd("2016-09-01")) %>% # After ou before the VGP closure
    mutate(year_rel = floor(time_length(ymd(as.Date(t_1h)) - ymd("2016-08-31"), "year"))) %>% # year relative to VGP closure
    mutate(log_flow = log(q),log_occupancy = log(k)) %>% # Log of the flow and occupancy of cars
    mutate(date = as.Date(t_1h)) %>%
    mutate(wday = wday(ymd(date))) %>% # Day of the week (1 = Saturday, 2 = Monday, ..., 7 = Sunday)
    mutate(hours = hour(t_1h)) %>% # Hour of the day (0 to 23)
    mutate(day_hour = paste0(wday,'_',hours)) %>% # Wednesday at 8AM = "4_8" and Sunday at 7PM =  "7_19"
    mutate(road = case_when(libelle %in% Lower_bank$Libelle ~ "LB",
                            libelle %in% Upper_bank$Libelle ~ "UB",
                            libelle %in% Bd_St_Germain$Libelle ~ "BSG",
                            ))
  
  Final_local$daytime = ifelse(Final_local$hours %in% c(8:19),TRUE,FALSE)
  Final_local$morning = ifelse(Final_local$hours %in% c(8:9),TRUE,FALSE)
  Final_local$evening = ifelse(Final_local$hours %in% c(18:19),TRUE,FALSE)
  
  return(Final_local)
}

date_min = "2013-09-01"
date_max = "2019-09-01"
df_local = loading_function(date_min,date_max)


Final_local = categories_function_local(df_local)

k_c = list()
for (i in unique(Final_local$iu_ac)){
  df = Final_local %>% filter(iu_ac == i, is.na(q) == F & is.na(k) == F)
  if(nrow(df) == 0){k_c[i]=NA
    }else{
    k_c[i] = -coef(lm(q ~ 0 + k + I(k^2), data = df))[1]/(2*coef(lm(q ~ 0 + k + I(k^2), data = df))[2])
    }
}

Final_local$kc = k_c[Final_local$iu_ac]
Final_local$congestion = ifelse(Final_local$k > Final_local$kc,1,0)

Final_local = left_join(Final_local,ref_local_roads %>% select(Identifiant.arc,length),by=c('iu_ac'='Identifiant.arc'), relationship = "many-to-many")
Final_local$length = as.numeric(Final_local$length)
Final_local$speed = compute_speed_test(Final_local)
Final_local$log_speed = log(Final_local$speed)


did_model <- feols(
  q ~ treated * post | iu_ac + t_1h,
  data = Final_local,
  cluster = ~iu_ac
)

summary(did_model)


# A function to compute the event model:
#   - Final_local is the data frame with the data filtered and with the categories
#   - subset is a CONDITION input ! e.g. "north == TRUE"
#   - variable to compute the model, e.g. "q", "k", "log_flow", "log_occupancy"...

compute_event_model = function(Final_local,subset,variable) {
  
  if (!is.null(subset)){
    df = Final_local %>% filter(!!parse_expr(subset))
  } else {df = Final_local}
  
  event_model <- feols(
    k ~ i(year_rel, treated, ref = "-1") | iu_ac + day_hour,
    data = df,
    cluster = ~iu_ac
  )
  
  summary(event_model)
  
  betas <- coef(event_model)
  ses <- se(event_model)
  
  results<- data.frame(
    coef_name = names(betas),
    beta = betas,
    se = ses,
    ci_low = betas - 1.96 * ses,
    ci_high = betas + 1.96 * ses
  )

  results = results %>% mutate(year_rel = sapply(coef_name,function(x) {return(unlist(str_split(x,":"))[3])}))
  results[6,] = c("year_rel::-1:treated",0,0,0,0,-1) # Add a line for the reference year (-1) with an estimate and se = 0
  results = results %>% select(-coef_name) %>% mutate(across(everything(),as.numeric))
  
  return(results)
}

results_all = compute_event_model(Final_local,subset = NULL,k)
results_all$subset = "all"

results_BSG = compute_event_model(Final_local, subset = "road != \"UB\"",k)
results_BSG$subset = "BSG"

results_UB = compute_event_model(Final_local, subset = "road != \"BSG\"",k)
results_UB$subset = "UB"

results = rbind(results_all,results_BSG,results_UB)

ggplot(results, aes(x = year_rel, y = beta, color = subset)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_point(size = 2, position = position_dodge(width = 0.3)) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0,position = position_dodge(width = 0.3)) +
  geom_line(position = position_dodge(width = 0.3))+
  labs(
    x = "Year relative to VGP closure",
    y = "Estimates (β_k)",
    title = "Effect of VGP closure on car occupancy rate"
  ) +
  theme_minimal() + 
  scale_color_manual(values = c("all" = "black", "BSG" = "darkgrey", "UB" = "darkblue"),
                     labels = c("all" = "Full sample - local", "BSG" = "Bd St Germain only", "UB" = "Upper bank only"))

```


```{r}

Final = Final_local

compute_model_plot = function(variable){
  
  fml <- as.formula(paste0(variable, " ~ i(year_rel, treated, ref = '-1') | libelle + day_hour"))
  
  event_model_daytime <- feols(
    fml,
    data = Final %>% filter(daytime == TRUE, road %in% c("BSG","UB","LB"), wday %in% c(2:6)),
    cluster = ~libelle
  )
  event_model_evening <- feols(
    fml,
    data = Final %>% filter(evening == TRUE, road %in% c("BSG","UB","LB"), wday %in% c(2:6)),
    cluster = ~libelle
  )
  event_model_morning <- feols(
    fml,
    data = Final %>% filter(morning == TRUE, road %in% c("BSG","UB","LB"), wday %in% c(2:6)),
    cluster = ~libelle
  )
  
  
  betas_morning <- coef(event_model_morning)
  ses_morning <- se(event_model_morning)
  
  results_morning <- data.frame(
    coef_name = names(betas_morning),
    beta = betas_morning,
    se = ses_morning,
    ci_low = betas_morning - 1.96 * ses_morning,
    ci_high = betas_morning + 1.96 * ses_morning
  )
  
  betas_evening <- coef(event_model_evening)
  ses_evening <- se(event_model_evening)
  
  results_evening <- data.frame(
    coef_name = names(betas_evening),
    beta = betas_evening,
    se = ses_evening,
    ci_low = betas_evening - 1.96 * ses_evening,
    ci_high = betas_evening + 1.96 * ses_evening
  )
  
  betas_daytime <- coef(event_model_daytime)
  ses_daytime <- se(event_model_daytime)
  
  results_daytime <- data.frame(
    coef_name = names(betas_daytime),
    beta = betas_daytime,
    se = ses_daytime,
    ci_low = betas_daytime - 1.96 * ses_daytime,
    ci_high = betas_daytime + 1.96 * ses_daytime
  )
  
  results_morning = results_morning %>% mutate(year_rel = sapply(coef_name,function(x) {return(unlist(str_split(x,":"))[3])}) %>% as.numeric())
  results_morning[6,] = c("year_rel::-1:treated",0,0,0,0,-1)
  results_morning = results_morning %>% select(-coef_name) %>% mutate(across(everything(),as.numeric))
  
  results_evening = results_evening %>% mutate(year_rel = sapply(coef_name,function(x) {return(unlist(str_split(x,":"))[3])}) %>% as.numeric())
  results_evening[6,] = c("year_rel::-1:treated",0,0,0,0,-1)
  results_evening = results_evening %>% select(-coef_name) %>% mutate(across(everything(),as.numeric))
  
  results_daytime = results_daytime %>% mutate(year_rel = sapply(coef_name,function(x) {return(unlist(str_split(x,":"))[3])}) %>% as.numeric())
  results_daytime[6,] = c("year_rel::-1:treated",0,0,0,0,-1)
  results_daytime = results_daytime %>% select(-coef_name) %>% mutate(across(everything(),as.numeric))
  
  
  
  results_daytime$hour = "daytime"
  results_morning$hour = 'morning'
  results_evening$hour = "evening"
  
  results = rbind(results_daytime,results_evening,results_morning)
  
  ggplot(results, aes(x = year_rel, y = beta, color = hour, shape = hour)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
    geom_point(size = 2, position = position_dodge2(0.5)) +
    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0, position = position_dodge(0.5)) +
    geom_line(position = position_dodge2(0.5))+
    labs(
      x = "Year relative to reform",
      y = paste0("Estimated effect (β_k) on ",as.character(variable)),
      ) +
    theme_minimal() + 
    scale_color_manual(values = c("black","darkgrey","darkblue"))
}



plot_occupancy = compute_model_plot("log_occupancy")
plot_flow = compute_model_plot("log_flow")
plot_speed = compute_model_plot("log_speed")
plot_congestion = compute_model_plot('congestion')

combined = grid.arrange(plot_occupancy,plot_flow,plot_speed,plot_congestion)
```

```{r}


library(dplyr)
library(zoo)      # pour rollmean
library(ggplot2)

long_run_tendency = function(df, variable, type){
  variable = enquo(variable)
  Final_na <- df %>%
    mutate(!!variable := na_if(!!variable, -Inf))



  df_monthly <- Final_na %>%
    mutate(month = floor_date(date, "month")) %>%   # transforme la date en AAAA-MM-01
    group_by(iu_ac, month, treated) %>%             # agrégation mensuelle par route
    summarise(
      mean_variable = mean(!!variable, na.rm = TRUE),
      .groups = "drop"
    )
  
  df_roll <- df_monthly %>%
    arrange(iu_ac, month) %>%
    group_by(iu_ac) %>%
    mutate(
      roll12 = zoo::rollmean(
        mean_variable, 
        k = 12,
        align = "right",
        fill = NA,
        na.rm = TRUE
      )
    ) %>%
    ungroup()
  
  df_roll_bis = df_roll %>% 
    group_by(treated, month) %>% 
    summarise(roll12 = mean(roll12,na.rm=TRUE))
  
  
  ggplot(df_roll_bis, aes(x = month, y = roll12, color = factor(treated))) +
    geom_line(size = 1.1) +
    theme_minimal(base_size = 14) +
    geom_vline(xintercept = as.Date("2016-09-01")) +
    labs(
      title = paste0(str_split(as_name(variable), '_')[1]," tendency - ", type),
      x = "Month",
      y = paste0("Rolling mean of ", str_replace(as_name(variable), '_',' '))
    )
}

local_occup = long_run_tendency(Final_local, log_occupancy, "local")
local_flow = long_run_tendency(Final_local, log_flow, "local")
ring_flow = long_run_tendency(Final_ring,log_flow,"ring")
ring_occup = long_run_tendency(Final_ring, log_occupancy, "local")

```
# Air pollution

```{r}
pollution = read.csv("pollution.csv") %>% mutate(hour = hour(ymd_hms(date))) %>% mutate(date = as.Date(date)) %>% rename(wnd_direction = direction, wnd_speed = speed, wnd_tmp = tmp)

pollution$hour[is.na(pollution$hour)] = 0


ring_pollution_ids = c("5360","5336","5332","5337","5335","5334","5358","5333","5328","5351","5327","5326","5329","5330","5347","5331")

ub_pollution_ids = c("11","444","447","6555","6299","3","4","440","12","10","9","442","7","438","645","5","6","446","4","8","3")

date_min = "2013-09-01"
date_max = "2016-09-01"

df_ring_pollution = Final_ring %>% filter(iu_ac %in% ring_pollution_ids, date %within% interval(date_min,date_max)) 

df_ub_pollution = Final_local %>% filter(iu_ac %in% ub_pollution_ids, date %within% interval(date_min,date_max))



pollution_ring = left_join(df_ring_pollution,pollution %>% filter(loc == "ring"),by=c('date'='date','hours'='hour'),relationship = "many-to-many") 

pollution_ub = left_join(df_ub_pollution,pollution %>% filter(loc == "VGP"),by=c('date'='date','hours'='hour'),relationship = "many-to-many")


model_pollution = feols(log(NO2) ~ log_speed + q + wnd_speed + wnd_direction + wnd_tmp | hours + month(date) + wday,
    data = pollution_ub %>% filter(is.na(log_speed) == F,abs(log_speed)!=Inf),
    cluster = ~iu_ac)


summary(model_pollution)
```

